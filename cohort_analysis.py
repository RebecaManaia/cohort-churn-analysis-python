# -*- coding: utf-8 -*-
"""Cohort Analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xCABpsd2w1ueMKmoJgJOEHhwjsPcl9BZ

# AnÃ¡lise de RetenÃ§Ã£o

Neste projeto, analiso o comportamento de retenÃ§Ã£o de clientes ao longo do tempo utilizando anÃ¡lise de coorte, curva de sobrevivÃªncia de Kaplan-Meier, funil de retenÃ§Ã£o e Churn.

A base simula assinaturas mensais recorrentes, com foco em identificar padrÃµes de churn e oportunidades de fidelizaÃ§Ã£o.

A anÃ¡lise resultou em insights estratÃ©gicos para retenÃ§Ã£o e fidelizaÃ§Ã£o, com destaque para os primeiros 3 meses crÃ­ticos, oportunidades de upgrade apÃ³s o 4Âº mÃªs e a necessidade de monitoramento ativo entre os meses 6 e 9.
"""

#Importar as bibliotecas necessÃ¡rias (usando o Colab):
import pandas as pd
from google.colab import files
from google.colab import drive
import datetime
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np

#Vincular ao caminho do drive que consta minha planilha e puxei o arquivo (vocÃª deve montar o drive e ajustar o caminho do arquivo, caso use seu notebook em outro ambiente):
drive.mount('/content/drive')
caminho_arquivo = '/content/drive/MyDrive/Dados para anÃ¡lise/Cohort/base_fake_assinaturas.xlsx'
df = pd.read_excel(caminho_arquivo)
df.head()

# Garantir que as datas estÃ£o no formato datetime
df['data_assinatura'] = pd.to_datetime(df['data_assinatura'])
df['data_cancelamento'] = pd.to_datetime(df['data_cancelamento'])

# Criar o mÃªs de coorte (mÃªs de entrada) O 'W' significa que queremos agrupar por mÃªs.
df['mes_coorte'] = df['data_assinatura'].dt.to_period('M').apply(lambda r: r.start_time)

# Gerar um dataframe auxiliar com todas as semanas entre entrada e cancelamento (ou data limite)
data_limite = df['data_assinatura'].min() + pd.DateOffset(months=11)

# Criar lista de linhas com cliente ativo por mÃªs (ajustada)
linhas = []

for _, row in df.iterrows():
    entrada = row['data_assinatura']
    cancelamento = row['data_cancelamento'] if pd.notnull(row['data_cancelamento']) else data_limite

    # Garantir que comeÃ§a no inÃ­cio do mÃªs da entrada
    entrada_inicio_mes = entrada.replace(day=1)

    meses_ativos = pd.date_range(start=entrada_inicio_mes, end=cancelamento, freq='MS')

    for mes in meses_ativos:
        linhas.append({
            'id_cliente': row['id_cliente'],
            'mes_coorte': row['data_assinatura'].to_period('M').start_time,
            'mes_observacao': mes
        })



#Criar expansÃ£o
df_expansao = pd.DataFrame(linhas)

# Calcular o nÃºmero de meses desde a entrada (M0, M1, M2...)
df_expansao['mes_relativo'] = (
    (df_expansao['mes_observacao'].dt.year - df_expansao['mes_coorte'].dt.year) * 12 +
    (df_expansao['mes_observacao'].dt.month - df_expansao['mes_coorte'].dt.month)
)

#Garantir que cada cliente conte apenas uma vez por mÃªs relativo
df_expansao = df_expansao.drop_duplicates(subset=['id_cliente', 'mes_coorte', 'mes_relativo'])


df_expansao['mes_relativo'].value_counts().sort_index()

df_expansao['mes_relativo'].value_counts().sort_index()

# Contar nÃºmero de clientes Ãºnicos por coorte e mÃªs relativo
cohort_data = df_expansao.groupby(['mes_coorte', 'mes_relativo'])['id_cliente'].nunique().reset_index()

# Total de clientes por coorte (M0)
cohort_sizes = cohort_data[cohort_data['mes_relativo'] == 0][['mes_coorte', 'id_cliente']]
cohort_sizes = cohort_sizes.rename(columns={'id_cliente': 'total_coorte'})

# Juntar os tamanhos com o restante
cohort_data = pd.merge(cohort_data, cohort_sizes, on='mes_coorte')

# Calcular a taxa de retenÃ§Ã£o (%)
cohort_data['retencao'] = cohort_data['id_cliente'] / cohort_data['total_coorte']

# Transformar em matriz para visualizaÃ§Ã£o
matriz_retencao = cohort_data.pivot(index='mes_coorte', columns='mes_relativo', values='retencao')

# Visualizar as primeiras linhas formatadas
matriz_retencao.style.format("{:.0%}")

# Garantir que o index e colunas estejam no formato adequado
matriz_formatada = matriz_retencao.copy()
matriz_formatada.index = matriz_formatada.index.strftime('%Y-%m')  # remove T00:00...
matriz_formatada.columns.name = 'PerÃ­odo'
matriz_formatada.columns = [f"{col+1:02}" for col in matriz_formatada.columns]
matriz_formatada.index.name = 'MÃªs de ReferÃªncia'

plt.figure(figsize=(14, 8))

sns.heatmap(
    matriz_formatada,
    annot=True,
    fmt=".0%",
    cmap="RdBu_r",
    cbar=True,
    linewidths=1,
    linecolor='white',
    vmin=0, vmax=1,
    square=True  # â† Deixa cada cÃ©lula em proporÃ§Ã£o quadrada
)

plt.title("Cohort Analysis (%)", fontsize=22, fontweight='bold', pad=20)
plt.xlabel("CohortPeriod", fontsize=14)
plt.ylabel("CohortGroup", fontsize=14)
plt.xticks(fontsize=12)
plt.yticks(fontsize=12, rotation=0)
plt.tight_layout()
plt.show()

"""### O grÃ¡fico acima mostra a taxa de retenÃ§Ã£o dos clientes mÃªs a mÃªs apÃ³s sua entrada. Ele indica o quÃ£o bem as coortes estÃ£o mantendo seus clientes ao longo do tempo.

*As cores vÃ£o do vermelho escuro (alta retenÃ§Ã£o) ao branco (baixa), e cada linha representa uma coorte (grupo de clientes que entrou no mesmo mÃªs). As colunas representam os meses desde a entrada (CohortPeriod).*

**Podemos perceber que a primeira grande queda ocorre no 2Âº ao 4Âº mÃªs para coortes mais antigas (jan a mar/24):**

Coorte de Janeiro: cai de 100% â†’ 72% em 3 meses.
Coorte de MarÃ§o: de 100% â†’ 59% em 4 meses.

ğŸ” *Sinal de problema no inÃ­cio do ciclo de vida.*

**Melhoria de retenÃ§Ã£o nas coortes recentes (mai e jun/24):**

Coorte de Maio mantÃ©m 91% atÃ© o 8Âº mÃªs.
Junho retÃ©m 97% por 7 meses seguidos.

ğŸŸ¢ *Sugere melhoria nas estratÃ©gias de onboarding ou produto. Recomendo analisar o que foi feito de estratÃ©gia durantes esses meses.*

**ğŸ¯ AÃ§Ãµes ou recomendaÃ§Ãµes:**

Investigar os primeiros 3 meses de jornada: Onde a maioria abandona â€” avaliar onboarding, valor percebido, suporte.

Replicar prÃ¡ticas das coortes mais recentes: Algo mudou (ex: comunicaÃ§Ã£o, bÃ´nus, melhorias?) que manteve mais clientes ativos.

Criar aÃ§Ãµes especÃ­ficas de engajamento nos meses crÃ­ticos (2 a 4): Pushs, ofertas, onboarding reforÃ§ado.

Monitorar se as coortes recentes mantÃªm a boa retenÃ§Ã£o com o tempo.




"""

# Calcular tempo mÃ¡ximo de retenÃ§Ã£o por cliente
tempo_por_cliente = df_expansao.groupby('id_cliente')['mes_relativo'].max() + 1  # â¬…ï¸ Aqui somamos +1

# Calcular mÃ©dia e mediana
media_tempo = tempo_por_cliente.mean()
mediana_tempo = tempo_por_cliente.median()

# Mostrar os valores
print(f"MÃ©dia de tempo de retenÃ§Ã£o: {media_tempo:.2f} meses")
print(f"Mediana de tempo de retenÃ§Ã£o: {mediana_tempo:.2f} meses")

plt.figure(figsize=(12, 6))
sns.histplot(tempo_por_cliente, kde=True, color="#4F81BD", bins=15, edgecolor="white", alpha=0.8)

# Linhas de mÃ©dia e mediana
plt.axvline(media_tempo, color='red', linestyle='--', linewidth=2, label=f'MÃ©dia: {media_tempo:.2f} meses')
plt.axvline(mediana_tempo, color='green', linestyle='--', linewidth=2, label=f'Mediana: {mediana_tempo:.2f} meses')

# EstÃ©tica
plt.title("DistribuiÃ§Ã£o do Tempo de RetenÃ§Ã£o (com KDE)", fontsize=16, fontweight='bold')
plt.xlabel("Meses de RetenÃ§Ã£o", fontsize=12)
plt.ylabel("Clientes", fontsize=12)
plt.xticks(fontsize=10)
plt.yticks(fontsize=10)
plt.legend()
plt.grid(axis='y', linestyle='--', alpha=0.5)
plt.xticks(range(1, tempo_por_cliente.max() + 1))  # â† forÃ§a ticks de 1 atÃ© o valor mÃ¡ximo
plt.tight_layout()
plt.show()

"""### O Histograma com curva de densidade (KDE) apresenta a distribuiÃ§Ã£o de tempo de vida dos clientes em meses, ou seja, por quanto tempo os clientes permanecem ativos antes de cancelarem ou inativarem.

*A linha vermelha representa a mÃ©dia e a linha verde a mediana do tempo de retenÃ§Ã£o.*

Podemos perceber que a retenÃ§Ã£o mÃ©dia e a mediana sÃ£o altas. MÃ©dia â‰ˆ 7,6 meses, Mediana â‰ˆ 8 meses.
âœ… Sinal positivo: mais da metade dos clientes permanece por atÃ© 8 meses.

**Temos uma distribuiÃ§Ã£o bimodal:**

Um pico nos primeiros meses (1 a 3) e outro pico entre 8 a 12 meses.
ğŸ” Isso indica dois comportamentos distintos: clientes que saem rapidamente e clientes que permanecem bastante tempo. ReforÃ§ando o que identificamos no primeiro grÃ¡fico.

ğŸ¯ **O que este grÃ¡fico sugere:**
A base fiel de clientes tem comportamento robusto â€” vale a pena estudar esse grupo para entender o que os mantÃ©m.

Pode ser interessante segmentar estratÃ©gias: uma para novos clientes (ativaÃ§Ã£o) e outra para clientes longevos (recompensa, upsell, fidelizaÃ§Ã£o).



"""

!pip install lifelines
from lifelines import KaplanMeierFitter

# Obter o tempo de retenÃ§Ã£o final por cliente
tempo_vida = df_expansao.groupby('id_cliente')['mes_relativo'].max().reset_index()
tempo_vida['meses_ativos'] = tempo_vida['mes_relativo'] + 1  # Ajustar M0 â†’ mÃªs 1

# Supondo que todos os clientes saÃ­ram (sem censura)
tempo_vida['evento_ocorreu'] = True  # 1 para evento (churn)

kmf = KaplanMeierFitter()
kmf.fit(durations=tempo_vida['meses_ativos'], event_observed=tempo_vida['evento_ocorreu'])

plt.figure(figsize=(12, 6))
kmf.plot(ci_show=True)
plt.title("Curva de SobrevivÃªncia - Kaplan-Meier", fontsize=16, fontweight='bold')
plt.xlabel("Meses desde a Entrada")
plt.ylabel("Probabilidade de RetenÃ§Ã£o")
plt.grid(axis='y', linestyle='--', alpha=0.5)
plt.tight_layout()
plt.show()

"""### Esse grÃ¡fico mostra a Curva de SobrevivÃªncia dos clientes usando o mÃ©todo Kaplan-Meier, que Ã© comumente utilizado em anÃ¡lises de churn e tempo de vida de clientes.

*Eixo X: Meses desde a entrada do cliente (tempo desde o inÃ­cio da assinatura).
Eixo Y: Probabilidade acumulada de um cliente ainda estar ativo (nÃ£o ter churnado) atÃ© aquele mÃªs.*

Podemos perceber que o Churn precoce Ã© crÃ­tico, visto que a maioria dos clientes sÃ£o perdidos nos primeiros meses e a retenÃ§Ã£o de longo prazo Ã© baixa, jÃ¡ que a maior parte dos clientes nÃ£o permanecem por mais de 12 meses.

**AÃ§Ãµes estruturadas nos primeiros meses podem ter grande impacto no LTV e retenÃ§Ã£o geral. Recomendo focar no onboarding e engajamento nos 3 primeiros meses e analisar a causa inicial desses chur para definir aÃ§Ãµes, criando campanhas de retenÃ§Ã£o especÃ­ficas.**


"""

# Converter valores para porcentagem mÃ©dia de retenÃ§Ã£o por mÃªs relativo
retencao_media_por_mes = matriz_retencao.mean().sort_index() * 100

# Plotar o grÃ¡fico de funil horizontal
plt.figure(figsize=(12, 6))
bars = plt.barh(
    y=[f"MÃªs {i+1}" for i in retencao_media_por_mes.index],
    width=retencao_media_por_mes.values,
    color=plt.cm.Reds(retencao_media_por_mes.values / 100),
    edgecolor='black'
)

# Adicionar os valores nas barras
for bar in bars:
    plt.text(bar.get_width() - 5, bar.get_y() + bar.get_height() / 2,
             f"{bar.get_width():.1f}%", va='center', ha='right',
             fontsize=10, color='white', fontweight='bold')

# EstÃ©tica
plt.title("Funil de RetenÃ§Ã£o por MÃªs Relativo", fontsize=18, fontweight='bold')
plt.xlabel("Taxa MÃ©dia de RetenÃ§Ã£o (%)", fontsize=12)
plt.ylabel("Meses desde a Entrada", fontsize=12)
plt.xlim(0, 100)
plt.grid(axis='x', linestyle='--', alpha=0.4)
plt.gca().invert_yaxis()  # Inverter eixo para parecer um funil
plt.tight_layout()
plt.show()

"""### Esse grÃ¡fico representa um Funil de RetenÃ§Ã£o por MÃªs Relativo, tambÃ©m conhecido como Retention Funnel. Ele mostra, mÃªs a mÃªs desde a entrada do cliente, qual a porcentagem mÃ©dia de clientes ainda ativos.

*Eixo Y (vertical): Meses desde a entrada do cliente (mÃªs 1 = entrada).*

*Eixo X (horizontal): Taxa mÃ©dia de retenÃ§Ã£o em cada mÃªs.*

*Barras horizontais: Representam a porcentagem mÃ©dia de clientes que permanecem ativos no mÃªs correspondente.*

Esse grÃ¡fico evidencia o que jÃ¡ vimos em nossa anÃ¡lise, por exemplo, que temos uma perda significativa nos primeiros meses, de 100% no mÃªs 1 para 88,3% jÃ¡ no mÃªs 3, indicando uma perda de ~12% em apenas 2 meses.

No mÃªs 4, a retenÃ§Ã£o jÃ¡ estÃ¡ em 80,5% â†’ Ã© um sinal de que os primeiros 3â€“4 meses sÃ£o crÃ­ticos para o churn.

Entretanto, temos leve estabilizaÃ§Ã£o entre os meses 5 e 7, Pequenas quedas (de 75,8% para 74,1%) mostram que quem passou do mÃªs 4 tende a permanecer por mais tempo e retornamos a queda significativa entre os meses 8 e 10, de modo que ao fim de 1 ano, apenas 56,9% dos clientes ainda estÃ£o ativos em mÃ©dia.

**Sendo assim, temos o reforÃ§o de que Onboarding e engajamento nos primeiros 3 meses sÃ£o essenciais. AlÃ©m disso, clientes que passam do mÃªs 4 tÃªm mais propensÃ£o a se manter, entÃ£o esse Ã© o momento ideal para oferecer planos de fidelizaÃ§Ã£o, upgrades ou recompensas.**
"""

# Calcular taxa de churn como complemento da taxa de retenÃ§Ã£o
churn_por_mes = 1 - matriz_retencao.mean().sort_index()

# Converter para porcentagem
churn_por_mes_percent = churn_por_mes * 100

# Plotar o grÃ¡fico
plt.figure(figsize=(12, 6))
plt.plot(
    churn_por_mes_percent.index + 1,  # ajusta MÃªs 0 para MÃªs 1
    churn_por_mes_percent.values,
    marker='o', linestyle='-', color='#D9534F', linewidth=2
)

# Adicionar valores nas marcaÃ§Ãµes
for i, value in enumerate(churn_por_mes_percent.values):
    plt.text(i + 1, value + 1, f"{value:.1f}%", ha='center', fontsize=10)

# EstÃ©tica
plt.title("Churn MÃ©dio por MÃªs Relativo", fontsize=16, fontweight='bold')
plt.xlabel("Meses desde a Entrada", fontsize=12)
plt.ylabel("Churn MÃ©dio (%)", fontsize=12)
plt.xticks(range(1, len(churn_por_mes_percent) + 1))
plt.grid(axis='y', linestyle='--', alpha=0.5)
plt.ylim(0, 100)
plt.tight_layout()
plt.show()

"""### O grÃ¡fico acima mostra o Churn MÃ©dio por MÃªs Relativo, ou seja, a percentual acumulada de clientes que cancelaram ao longo dos meses desde a entrada na base.

*Eixo X: Meses desde a entrada do cliente (mÃªs 1 = entrada).*

*Eixo Y: Porcentagem mÃ©dia de churn acumulado (%).*

Novamente identificamos abandono precore atÃ© o mÃªs 3, talvez por falta de engajamento, onboarding ruim ou expectativas nÃ£o atendidas. EntÃ£o precisamos identificar isso (analisando a pesquisa de cancelamento) para seguir com o plano de aÃ§Ã£o adequado.

A curva Ã© crescente e contÃ­nua, o que Ã© tÃ­pico de churn acumulado, mas a inclinaÃ§Ã£o mostra onde as maiores perdas ocorrem.

ğŸ“ŒEntÃ£o concluÃ­mos essa anÃ¡lise com as seguintes sugestÃµes:

**1. AtuaÃ§Ã£o rÃ¡pida nos primeiros 3 meses:**

ReforÃ§ar onboarding, comunicaÃ§Ã£o de valor e benefÃ­cios.

Incentivos de retenÃ§Ã£o (descontos, conteÃºdo exclusivo, bÃ´nus).

**2. Upgrade e fidelizaÃ§Ã£o entre o 4Â° e 5Â° mÃªs:**

Clientes que passam do mÃªs 4 tÃªm mais propensÃ£o a se manter, como identificamos no funil de retenÃ§Ã£o, entÃ£o esse Ã© o momento ideal para oferecer planos de fidelizaÃ§Ã£o, upgrades ou recompensas.

**3. Monitoramento nos meses 6 a 9:**

Investigar gatilhos de churn (pesquisa, comportamento).

Implementar estratÃ©gias de reengajamento (notificaÃ§Ãµes, atualizaÃ§Ãµes, promoÃ§Ãµes).


**4. Benchmarking:**

Se o churn anual acima de 40% for alto comparado ao seu mercado, Ã© um sinal claro de alerta.


"""